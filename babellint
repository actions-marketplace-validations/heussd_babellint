#!/bin/bash
set -o errexit
set -o pipefail
set -o nounset


function print {
    echo -e "\033[0;34m[babellint]\033[0m $1"
}
function printerr {
    print "\033[0;31m𐄂 $1 \033[0m"
}
function printok {
    print "\033[0;32m✓\033[0m $1"
}

function fail {
    printerr "$1 via $(echo "$BASH_COMMAND" | awk '{print $1;}')"
    exit 1
}


if [ $# -eq 0 ]; then
    # Do explicit file provided. List files myself and call self with each.

    GITDIR=".git"
    if [[ -e "$(pwd)/.dotfiles-bare-repo/" ]]; then
        GITDIR=".dotfiles-bare-repo"
    fi

    if [[ ! -e "$GITDIR" ]]; then
        # No git folder exists. Terminate silently
        exit 0
    fi

    git --git-dir="$GITDIR" ls-files | tr "\n" "\0" | xargs -I {} -0 bash -c "$0 \"{}\"" || exit 1
    exit
fi


for file in "$@"; do
    # In sparse repositories, some files might be listed but not exist. Skip these.
    if [[ ! -e "$file" ]]; then
        continue
    fi
    trap 'fail "$file"' ERR


    # Casing should not matter
    name=$(echo "$file" | tr '[:upper:]' '[:lower:]')
    case "$name" in
        dockerfile)
            hadolint "$file" --ignore DL3059
            ;;
        readme.md)
            if [[ -e ".wordlist.txt" ]]; then
                cp ".wordlist.txt" /root/wordlist.txt
            fi

            # Assume that the current folder is a valid proper name
            folder=${PWD##*/}
            echo "$folder" >> /root/wordlist.txt

            pyspelling --config /root/pyspelling-readme-md.yml --name "Readme.md" --source "$file" | head -n -1
            ;& # Yes, fall through please
        *.md)
            markdownlint "$file"
            ;;
        *.json)
            jq . "$file" > /dev/null
            ;;
        *.yaml)
            ;&
        *.yml)
            yamllint "$file"
            ;;
        *)

            mimetype=$(file --brief --mime-type "$file")
            case "$mimetype" in
                text/x-shellscript)
                    shellcheck --color=always "$file"
                    ;;
                *)
                    exit 0
                    ;;
            esac
            
            ;;
    esac

    printok "$file"
done

